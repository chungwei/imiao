# Go 切片的使用和原理

> 原文请参看 [Go官方博客](https://blog.golang.org/go-slices-usage-and-internals)  

## 介绍
切片是 golang 提供的一种基本数据结构，实用且效率高，切片类似于其他语言的数组，但又稍有区别。  
本文讲带你了解切片的原理和使用。

## 数组
切片是在数组的基础上抽象出来的数据结构，所以在理解切片之前，我们先了解一下数组。  

数组定义的是固定长度和元素类型的数据集合。例如，`[4]int` 声明了包含4个int类型的数组，其长度是固定的，`[4]int` 和 `[5]int` 完全不一样。数组有索引，索引从0开始，`s[n]` 表示第n个元素，如以下示例  
```
var a [4]int
a[0] = 1
i := a[0]
// i == 1
```

数组的值不需要进行显式初始化，实际上在声明完成后，数组里每个元素已经是0值，
```
var a [4]int
fmt.Printf("%v", a) // [0 0 0 0]
```
在内存中，[4]int是一块用于存储4个int类型的连续内存块，如下图  

![IMAGE](./resources/go-slices-usage-and-internals_slice-array.png)

Go数组是值类型，一个数组变量是指整个数组，而不是像C语言只是指向数组第一个元素的指针。这意味着给数组赋值或使用数组传值实际上是对其副本的操作，(为避免值复制可以传递一个指向数组的指针，但要注意的这是一个指向数组的指针而不是数组的值)。对于数组，换一个角度来理解，可认为它是一个固定长度的结构体，只是用索引取代了成员。  

数组可以像如下声明
```
b := [2]string{"Penn", "Teller"}
```
或者，也可以这么定义
```
b := [...]string{"Penn", "Teller"}
```

以上两种方式，变量b的类型都是[2]string  

## 切片
数组是适用于很多场景，但不够灵活，所以在Go的代码里用到数组的并不多，相反，切片的使用很频繁。切片在数组的基础上做了封装，提高了更强大、更便利的功能。

切片的声明，如`[]T`，其中的`T`是切片元素的类型，跟数组不一样之处，切片是不需要指定长度的。  
切片可以像如下声明
```
letters := []string{"a", "b", "c", "d"}
```
也可以使用内置函数`make`
```
func make（[] T，len，cap）[] T
```
其中，`T`是切片元素的类型，`make`方法需要3个参数，类型、长度和容量(可选的)。调用该方法后，实际上是分配了一个数组的内存空间，并返回一个引用该数组的切片。

示例如
```
var s []byte
s = make([]byte, 5, 5)
// s == []byte{0, 0, 0, 0, 0}

```
如果容量参数`cap`被忽略，默认为`cap` 等于`len`，所以你可以看到以上代码更简洁的版本如下
```
s := make([]byte, 5)
```
要获取切片的容量和长度，可以使用内置方法`cap` 和 `len`，如
```
len(s) == 5
cap(s) == 5
```
接下来的我们继续讨论一下长度和容量的差异。  
一个0值的切片实际上是`nil`，其长度和容量都是0。  
除了上面提到的定义方式，切片还可以通过已存在的切片、数组的其中一部分来完成定义。例如，`b[1:4]` 定义了一个新的切片，它包含切片`b`的第1，2，3个元素(从0开始计算)，在新的切片里，这3个元素的索引是0-2
```
b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b
```
上述例子中的切片索引是可以省略的，默认是从0到切片的长度(即len(b))，
```
// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
```

此外，还可以使用数组来定义切片，如
```
x := [3]string{"Лайка", "Белка", "Стрелка"}
s := x[:] // a slice referencing the storage of x
```

## 切片原理
切片是数组段的描述符，它包含指向数组段的指针、数组段的长度和数组段的容量。如下图  
> 容量是指数组的最大长度

![IMAGE](./resources/go-slices-usage-and-internals_slice-struct.png)

如上述我们定义的切片`s = make([]byte, 5)`，其结构如下图

![IMAGE](./resources/go-slices-usage-and-internals_slice-1.png)

切片的长度是指引用的数组段的元素个数，而容量是底层数组的长度。接下来我们将通过几个示例来明确长度和容量的差异。  

还是我们上面的切片 `s`，我们看一下其数据结构和底层数组的关系  
```
s = s[2:4]
```
![IMAGE](./resources/go-slices-usage-and-internals_slice-2.png)

从上图可以看出，切片的赋值并没有复制原来切片的数据，而是创建了一个新的指针指向，这样就可以保证对切片的操作跟数组一样高兴。但是，修改新切片的值，则会影响到原来的切片：
```
d := []byte{'r', 'o', 'a', 'd'}
e := d[2:] 
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
```
再次提到我们上面的切片 `s`，目前它的长度小于容量，我们可以把它的长度增长到等于其容量：
```
s = s[:cap(s)]
```
![IMAGE](./resources/go-slices-usage-and-internals_slice-3.png)


