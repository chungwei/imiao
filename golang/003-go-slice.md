# Go 切片的使用和原理

> 原文请参看 [Go官方博客](https://blog.golang.org/go-slices-usage-and-internals)  

## 介绍
切片是 golang 提供的一种基本数据结构，实用且效率高，切片类似于其他语言的数组，但又稍有区别。  
本文讲带你了解切片的原理和使用。

## 数组
切片是在数组的基础上抽象出来的数据结构，所以在理解切片之前，我们先了解一下数组。  

数组定义的是固定长度和元素类型的数据集合。例如，`[4]int` 声明了包含4个int类型的数组，其长度是固定的，`[4]int` 和 `[5]int` 完全不一样。数组有索引，索引从0开始，`s[n]` 表示第n个元素，如以下示例  
```
var a [4]int
a[0] = 1
i := a[0]
// i == 1
```

数组的值不需要进行显式初始化，实际上在声明完成后，数组里每个元素已经是0值，
```
var a [4]int
fmt.Printf("%v", a) // [0 0 0 0]
```
在内存中，[4]int是一块用于存储4个int类型的连续内存块，如下图  
![IMAGE](./resources/go-slices-usage-and-internals_slice-array.png)

Go数组是值类型，一个数组变量是指整个数组，而不是像C语言只是指向数组第一个元素的指针。这意味着给数组赋值或使用数组传值实际上是对其副本的操作，(为避免值复制可以传递一个指向数组的指针，但要注意的这是一个指向数组的指针而不是数组的值)。对于数组，换一个角度来理解，可认为它是一个固定长度的结构体，只是用索引取代了成员。  

数组可以像如下声明
```
b := [2]string{"Penn", "Teller"}
```
或者，也可以这么定义
```
b := [...]string{"Penn", "Teller"}
```

以上两种方式，变量b的类型都是[2]string  

## 切片

## 切片原理
